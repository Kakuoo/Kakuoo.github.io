---
layout: post
title: Python异常
subtitle: false
tags: [Python]
---

<!-- ##  Python异常 -->

### 异常的概念

- 程序在运行时，如果python解释器遇到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常
- 程序停止执行并且提示错误信息这个动作，我们通常称之为：**抛出（raise）异常**

### 捕获异常

#### 1.简单的捕获异常语法

- 在程序开发中，如果对于某些代码的执行不能确定是否正确，可以增加try（尝试）来捕获异常

语法格式如下：

```python
try:
	尝试执行的代码
except:
	出现错误的处理
```

- `try` **尝试**，下方编写要尝试的代码，不确定是否能够正常执行的代码
- `except` **如果不是**，下方编写尝试失败的代码

#### 2.错误类型捕获异常

在程序执行时，可能会遇到不同类型的异常，并且需要针对不同类型的异常，做出不同的响应，此时，需要捕获错误类型，语法如下：

```python
try:
    pass
except 错误类型1:
    pass
except (错误类型2, 错误类型3):
    pass
except Exception as result:
    print("未知错误 %s" % result)
```

> 当python解释器**抛出异常**时，**最后一行错误信息的第一个单词，就是错误类型**

```python
try:
    # 提示用户输入一个整数
    num = int(input("输入一个整数："))
    result = 8 / num
    print(result)

except ZeroDivisionError:
    print("除0错误")
except ValueError:
    print("请输入正确的整数")
```

**捕获未知错误**

如果希望程序无论出现任何错误，都不会因为Python解释器抛出异常而终止，可以再增加一个`except`，语法如下：

```python
except Exception as result:
    print("未知错误 %s" % result)
```

#### 3.异常捕获完整语法

```python
try:
    pass
except 错误类型1:
    pass
except 错误类型2:
    pass
except (错误类型3, 错误类型4):
    pass
except Exception as result:
    print(result)
else:
	# 没有异常才会执行的代码
	pass
finally:
	# 无论是否有异常，都会执行的代码
	print("无论是否有异常，都会执行的代码")
```

- `else` 只有在没有异常时才会执行的代码
- `finally` 无论是否有异常，都会执行的代码

### 异常的传递

- 当**函数/方法**执行**出现异常**，会**将异常传递**给函数/方法的**调用一方**
- 如果 **传递到主程序**，仍然**没有异常处理**，程序才会被终止

**提示：**

- 在开发中，可以在**主函数**中增加 **异常捕获**
- 而在主函数中调用的其他函数，只要出现异常，都会传递到主函数的**异常捕获**中
- 这样就不需要在代码中，增加大量的异常捕获，能够保证代码的整洁

```python
def demo1():
    return int(input("请输入一个整数："))

def demo2():
    return demo1()

# 利用异常的传递性，在主程序中捕获异常
try:
    demo2()
except Exception as result:
    print("未知错误 %s" % result)
```

### 抛出异常raise

- 在python中，提供了一个`Exception`异常类
- 在开发时，如果满足特定业务需求时，希望抛出异常，可以：
  1. 创建一个`Exception`的 对象
  2. 使用`raise`**关键字**抛出 **异常对象**

```python
def input_password():
    # 1. 提示用户输入密码
    pwd = input("输入密码：")
    # 2. 判断密码长度>=8，返回用户输入的密码
    if len(pwd) >= 8:
        return pwd
    # 3. 如果<8主动抛出异常
    print("主动抛出异常")
    # 1> 创建异常对象——可以使用错误信息字符串作为参数
    ex = Exception("密码长度不够")
    # 2> 主动抛出异常
    raise ex

try:
    print(input_password())
except Exception as result:
    print(result)
```



## Python模块

### 模块的概念

- 每一个以扩展名`.py`结尾的python源码文件都是一个模块
- 模块名同样也是一个标识符，需符合标识符的命名规则
- 在模块中定义的全局变量、函数、类 都是提供给外界直接使用的工具
- 模块就好比是工具包

### 模块的两种导入方式

#### 1）import 导入

```python
import 模块名1, 模块名2
```

> 提示：在导入模块时，每个导入应该独占一行

```python
import 模块名1
import 模块名2
```

> 导入之后：
>
> 通过`模块名.`使用模块提供的工具——**全局变量、函数、类**

**使用`as`指定模块的别名**

> 如果模块的名字太长，可以使用as指定模块的名称，方便在代码中使用

```python
import 模块名1 as 模块别名
```

> 注意：**模块别名** 需要符合**大驼峰命名法**

#### 2）from...import 导入

- 如果希望从某一个模块中，导入**部分**工具，就可以使用`from...import`的方式
- `import 模块名` 是一次性把模块中**所有工具全部导入**，并且通过**模块名/别名**访问

```python
# 从 模块 导入 某一个工具
from 模块名1 import 工具名
```

> 导入之后：
>
> - **不需要**通过 `模块名.`
> - 可以直接使用 模块提供的工具——**全局变量、函数、类**

**注意：**

> 如果 两个模块，存在**同名函数**，那么后导入模块的函数，会 **覆盖**先导入的函数

- 在开发时，import代码应该统一写在代码的顶部，更容易及时发现冲突
- 一旦发现冲突，可以使用`as`关键字给**其中一个工具起一个别名**

**from...import ***

```python
# 从 模块 导入 所有工具
from 模块1 import *
```

> 注意：这种方式不推荐使用，因为函数重名并没有任何提示，出现问题不好排查

### 模块的搜索顺序 

1. 搜索 **当前目录** 指定模块名的文件，如果有就直接导入
2. 如果没有，再搜索**系统目录**

> 在开发时，给文件起名，不要和**系统的模块文件**重名

Python中每一个模块都有一个内置属性`__file__`可以 **查看模块的完整路径**

```python
import random

# 生成一个 0 ~ 10 的数字
rand = random.randint(0, 10)
print(rand)
```

> 注意：如果当前目录下，存在一个`random.py`的文件，程序就无法正常执行了，此时，python的解释器会 **加载当前目录** 下的`random.py`而不会加载**系统的**`random`模块

### 原则——每一个文件都应该是可以被导入的

- 一个独立的python文件就是一个模块
- 在导入文件时，文件中 **所有没有任何缩进的代码** 都会被执行一遍

实际开发场景

- 在实际开发中，每一个模块都是被独立开发的，大多有专人负责
- 开发人员通常会在**模块下方添加一些测试代码****（仅在模块内使用，而被导入到其他文件中不需要执行）**

**\_\_name__属性**

> 该属性可以做到，测试模块的代码只在测试情况下被运行，而在被导入时不会被执行！

- `__name__`是python的一个内置属性，记录着一个**字符串**
- 如果 **是当前执行的程序**，`__name__`是`__main__`
- 如果 **是被其他文件导入的**，`__name__`就是**模块名**

```python
# 导入模块
# 定义全局变量
# 定义类
# 定义函数

# 在代码的最下方
def main():
	# ...
	pass

# 根据__name__判断是否执行以下代码
if __name__ == "__main__":
	main()
```



## Python包（package）

- 包 是一个包含有**多个模块**的特殊目录
- 目录下有一个**特殊的文件**`__init__.py`
- 包名 的**命名方式** 和变量名一致，**小写字母**+`_`（可以有数字）

> 优点：可以使用`import 包名`一次性导入包中的**所有模块**

`__init__.py`

要在外界使用包中的模块，需要在`__init__.py`中指定对外界提供的模块列表

```python
# 从 当前目录 导入 模块列表
from . import send_message
from . import receive_message
```



## Python发布模块

### 制作发布压缩包步骤

#### 1）创建`setup.py`文件

```python
from distutils.core import setup

setup(
    name="GOGOGO",  # 包名
    version="1.0",  # 版本
    description="这个包用来上天的！",  # 描述信息
    long_description="没错，你没看错！",  # 完整描述信息
    author="GBJ",  # 作者
    author_email="123456@XX.com",  # 作者邮箱
    url="kakuguo.ink",  # 主页
    py_modules=["GO.forward",
                "GO.backward"])
```

有关字典参数的详细信息，可以参阅[官方网站](https://docs.python.org/2/distutils/apiref.html)

#### 2）构建模块

```shell
$ python3 setup.py build
```

#### 3）生成发布压缩包

```shell
$ python3 setup.py sdist
```

###  安装模块

```shell
$ tar -zxvf GO_message-1.0.tar.gz

$ sudo python3 setup.py install
```

###  卸载模块

直接从安装目录下，把安装模块的目录删除即可

```shell
# 使用__file__查看包的完整路径
# 卸载前可现在python环境下查看包的完整路径
>>> import GOGOGO
>>> GOGOGO.__file__

$ cd /usr/local/lib/python3.6/dist-packages/
# sudo rm -r GO_message*
```

### pip安装第三方模块

- 第三方模块通常是指由知名的第三方团队开发的并且被程序员广泛使用的python包/模块
- pip是一个现代的，通用的Python包管理工具
- 提供了对Python包的查找、下载、安装、卸载等功能

```shell
# 将模块安装到Python2.x环境
sudo pip install pygame
sudo pip uninstall pygame

# 将模块安装到Python3.x环境
sudo pip3 install pygame
sudo pip3 uninstall pygame
```

 

## Python文件

文本文件：

- 可以使用文本编辑软件查看
- 本质上还是二进制文件
- 程序文件

二进制文件：

- 二进制文件不能使用文本编辑软件查看
- 保存的内容 不是给人阅读的，而是提供给其他软件使用的
- 例如：图片文件、音频文件、视频文件等

### 文件的基本操作



| 函数/方法 | 说明                           |
| --------- | ------------------------------ |
| open      | 打开文件，并且返回文件操作对象 |
| read      | 将文件内容读取到内存           |
| write     | 将指定内容写入文件             |
| close     | 关闭文件                       |

- open 函数负责打开文件，并且返回文件对象
- read/write/close 三个方法都需要通过文件对象调用

### read读取文件

- read方法可以**一次性读入**并返回文件所有内容
- close方法负责关闭文件（**如果忘记关闭文件，会造成系统资源消耗，并且会影响到后续对文件的访问**）

注意：方法执行后，会把文件指针移动到文件的末尾

**文件指针**

- 文件指针标记从哪个位置开始读取数据
- 第一次打开文件，通常文件指针会指向文件的开始位置
- 当执行了read方法后，文件指针会移动到读取内容的末尾（默认情况）

### open打开文件

open函数默认以只读方式打开文件，并且返回文件对象

| 访问方式 | 说明                                                         |
| :------: | ------------------------------------------------------------ |
|    r     | 以只读方式打开文件。<br />文件的指针会放在文件开头（**默认模式**）。<br />若文件不存在，抛出异常 |
|    w     | 以只写方式打开文件。<br />如果文件存在会被覆盖。<br />如果文件不存在，创建新文件 |
|    a     | 以追加方式打开文件。<br />如果该文件已存在，文件指针放在文件末尾。<br />如果文件不存在，创建新文件进行写入 |
|    r+    | 以读写方式打开文件。<br />文件指针放在文件开头。<br />如果文件不存在，抛出异常 |
|    w+    | 以读写方式打开文件。<br />如果文件存在会被覆盖。<br />如果文件不存在，创建新文件 |
|    a+    | 以读写方式打开文件。<br />如果文件已存在，文件指针放在文件末尾。<br />如果文件不存在，创建新文件并写入 |

> 提示：频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候以只读，只写的方式来操作文件

### readline按行读取

- 一次读取一行内容
- 方法执行后，文件指针移动到下一行，准备再次读取

```python
# 打开文件
file = open("README", "r")

while True:
	text = file.readline()
    
    # 判断是否读取到内容
    if not text:
        break
    
    # 每行的末尾已经有了一个"\n"
	print(text, end="")
	
file.close()
```

### 文件/目录常用管理操作（os 模块）

**文件操作**

| 方法名 | 说明       | 示例                            |
| ------ | ---------- | ------------------------------- |
| rename | 重命名文件 | os.rename(源文件名，目标文件名) |
| remove | 删除文件   | os.remove(文件名)               |

**目录操作**

| 方法名     | 说明           | 示例                    |
| ---------- | -------------- | ----------------------- |
| listdir    | 目录列表       | os.listdir(目录名)      |
| mkdir      | 创建目录       | os.mkdir(目录名)        |
| rmdir      | 删除目录       | os.rmdir(目录名)        |
| getcwd     | 获取当前目录   | os.getcwd(目录名)       |
| chdir      | 修改工作目录   | os.chdir(目标目录)      |
| path.isdir | 判断是否是文件 | os.path.isdir(文件路径) |

> 提示：文件或目录操作都支持 相对路径 和 绝对路径



## Python文本编码

文本文件存储的内容是基于字符编码的文件，常见的编码有`ASCII`编码，`UNICODE`编码等

> python2.x 默认使用 `ASCII` 编码
>
> python3.x 默认使用 `UTF-8` 编码

ASCII 编码

- 计算机中只有256个`ASCII`字符
- 一个`ASCII`在内存中占用**1个字节**的空间

UTF-8 编码格式

- 计算机中使用**1-6个字节**来表示一个`UTF-8`字符，涵盖了地球上几乎所有地区的文字
- 大多数汉字会使用**3个字节**表示
- `UTF-8`是`UNICODE`编码的一种编码格式

### 在Python2.x中如何使用中文

在python2.x的文件的第一行增加以下代码，解释器会以utf-8编码来处理python文件

```python
# *-* coding:utf8 *-*
```

> 此种方式为官方推荐

也可以使用

```python
# coding=utf8
```

unicode 字符串

- 在python2.x中，即使指定了文件使用`utf-8`编码格式，但是在遍历字符串时，仍然会**以字节为单位遍历**字符串
- 要能够正确遍历字符串，在定义字符串时，需要在**字符串的引号前面**，加`u`，告诉解释器这是一个`unicode`字符串（使用`UTF-8`编码格式的字符串）

```python
str = u"你好，世界"
```



