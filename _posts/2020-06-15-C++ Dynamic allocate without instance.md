---
layout: post
title: C++实现只能动态分配类对象，不能定义类对象
subtitle: 每天一个令人震惊的新知识
tags: [C++]
---

<!-- ## C++实现只能动态分配类对象，不能定义类对象 -->

在C++中，类的对象建立分为两种，一种是静态建立，如`A a`；另一种是动态建立，如`A* ptr=new A`；这两种方式是有区别的。

**1、静态建立类对象：**是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后（编译器）在这片内存空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。当使用完了后，编译器自动调用析构函数对这片栈内存进行释放。

**2、动态建立类对象：**是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是（编译器）执行operator new()函数，在堆空间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。当对象使用完毕后delete也会调用析构函数对堆上的内存进行释放

### 动态分配类对象

只能在堆上分配类对象，就是不能静态建立类对象，即不能直接调用类的构造函数。

容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载`operator new()`函数，而`operator new()`函数只用于分配内存，无法提供构造功能。因此，这种方法不可以。

当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，**如果类的析构函数是私有的，则编译器无法调用析构函数来释放内存**。

所以，**编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了**。代码如下：

```c++
// 一种简单但是有缺陷的实现方式
class Base
{
public:
    Base() {}
    void destory() { delete this; }

protected:
    ~Base() {}
};

int main()
{
    // Base p;
    Base *p = new Base;
    p->destory();
    
    return 0;
}
```

试着使用`A a`;来建立对象，会编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，可以直接调用。类中必须提供一个`destory()`函数，来进行内存空间的释放。类对象使用完成后，必须调用`destory()`函数。

上述方法的缺点：

 **1、无法解决继承问题**。

如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。

 **2、类的使用不方便，使用new建立对象，却使用destory()函数释放对象，而不是使用delete。**

（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于**单例模式**：

**create函数设为static,原因是，创建对象的时候 Base \*p = Base::create() , 只有静态成员函数才能有类名直接访问，把类的构造函数和析构函数设为protected属性。类对象不能访问，但是派生类可以继承，也可以访问。**

```c++
class Base
{
public:
    static Base *create() { return new Base(); }
    void destory() { delete this; }

protected:
    Base() {}
    ~Base() {}
};

int main()
{
    // Base p;
    Base *p = Base::create();
    p->destory();
    
    return 0;
}
```

这样，调用create()函数在堆上创建类A对象，调用`destory()`函数释放内存。

### 静态分配类对象

只能在栈上分配类对象

只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。虽然你不能影响`new operator`的能力（因为那是C++语言内建的），但是你可以利用一个事实：`new operator` 总是先调用 `operator new`，而后者我们可以自行声明重写的。因此，将`operator new()`设为私有即可禁止对象被new在堆上。代码如下：

```c++
class Base
{
public:
    Base() {}
    ~Base() {}

private:
    void* operator new(size_t t) {}  // 注意分配函数的第一个参数和返回值都是固定的size_t类型
    void operator delete(void *ptr) {}  // 重载了new就需要重载delete
};

int main()
{
    Base p;
    // Base *t = new Base();

    return 0;
}
```

### 思考

**在栈上创建对象和在堆上创建对象的共同点：**

我们会发现，无论是`A a`；还是`A* a=new A()`；都会由编译器在类外部调用类的构造函数来创建对象。同样在释放内存空间时候也是会由编译器调用类的析构函数来释放。

**不同点在于：**

**栈对象的创建**过程中分配内存然后调用构造函数和对象释放过程中释放内存然后析构函数的调用都是编译器自动完成的。**堆对象的创建**过程中需要先由编译器显式的调用`operator new()` 函数进行内存分配，堆的释放过程中需要先由编译器显式的调用`operator delete()` 函数，然后编译器自动调用析构函数。

**为了只能在栈上创建对象**，那么我们就可以将operator new（）函数和operator delete（）函数进行重载，这两个函数不做任何事情不分配内存，并将他们设置为private，那么编译器就无法调用这两个函数。也就不能再堆上创建对象了，此时的构造函数和析构函数还是可以被编译器自由的调用创建栈对象。

**为了只能在堆上创建对象**，那么我们就必须让编译器不能自动调用构造函数和析构函数（虽然编译器能够自动分配内存但是没有调用构造函数，栈对象就没办法创建完成）。所以将构造函数和析构函数都设置为protected，这样编译器就不能调用了，但是创建堆对象也要由编译器调用构造函数和析构函数怎么办呢，得益于堆对象的创建过程需要调用类中定义的函数，那么我们可以定义两个函数create和destroy函数分别在内部调用构造函数和析构函数，这样就可以由编译器在堆上创建和释放对象。



参考文章：[SuperWe CSDN](<https://blog.csdn.net/SuperWe/article/details/51497013?utm_medium=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-OPENSEARCH-1.channel_param>)