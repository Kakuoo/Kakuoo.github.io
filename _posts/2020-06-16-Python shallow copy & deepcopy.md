---
layout: post
title: Python深浅拷贝
subtitle: false
tags: [Python]
---

<!-- ## Python深浅拷贝 -->

## 背景

开发工作中，有时候我们希望可以快速复制一个对象，python封装了内置函数copy模块中有copy与deepcopy函数，其中 copy是浅拷贝，deepcopy是深拷贝。在学习这俩个点时 我们需要弄清楚以下几点：

1. 为什么需要copy模块 ？
2. 有了copy为什么需要deepcoy ，即与copy的差异？
3. 如何自己实现一个copy方法？
4. 如何自己实现一个deepcoy方法？
5. 实例化的对象是可变对象还是不可变对象？
6. 不论浅拷贝还是深拷贝，不可变对象内存地址与拷贝对象的内存地址一样,而可变对象内存地址与拷贝对象的内存地址不一样，这句话错在哪，举例说明？
7. 该模块不复制模块、方法、栈追踪（stack trace）、栈帧（stack frame）、文件、套接字、窗口、数组以及任何类似的类型。它通过不改变地返回原始对象来（浅层或深层地）“复制”函数和类；这与`pickle`模块处理这类问题的方式是相似的

通过阅读正文可以了解以上问题

### 基础知识

在python中，每个对象有以下三个属性：

1、`id`，每个对象都有一个唯一的身份标识自己，可通过内建函数`id(obj)`查看。

2、`type`，对象的类型决定了该对象可以保存什么类型的值，可用内建函数`type(obj)`查看；

3、`value`，即对象的值。

关系运算符 `==`比较的是**两个对象的值是否相等**，而 `is` 比较的是两个**变量**是否为同一个**对象**（或者说**指向同一块内存**）。

Python中使用了智能指针的技术（与Java中的垃圾回收GC机制类似），每个变量都和指向对象（object）的指针相关联，每一个object都有一个**reference counter（引用计数器）**记住有多少个变量和这个object绑定（bind）。每次bind，reference count都加1，每次删除bind关系，都减少1，只有reference counter变成0的时候才真正删除对象。

###  Python-不可变对象与可变对象

#### 不可变对象

不可变对象，不可以修改对象，即该对象所指向的内存中的值不能被改变。**当改变某个变量时候，由于其所指的值不能被改变，相当于把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址**，使用id()方法获取对象的内存地址，`a=b=2`,`id(a)`与`id(b)`是一样的，当操作 `a+=1`时 `a=3` ，而`b=2`，`2`这个对象是没有发生改变的，**注意是对象而不是变量**。

####  可变对象

该对象所指向的内存中的值可以被改变，对象可以修改，此时内存地址不变。**变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变**。
例如：`testone=[1,2]`，`id(test_one)=140474965482144`*，*`testone.append(3)`,而`id(test_one)`内存地址没发生变化

**不可变类型**：数值类型（int和float）、字符串str、元组tuple，bool, None, tuple, bytes, frozenset

**可变类型**：列表list、字典dict、集合set，bytearray

**不可变对象的方法通常有返回值，而可变对象的方法通常返回None**，这是因为不可变对象因为对象自身无法修改，因此其方法只能返回一个新对象；而可变对象直接原地修改原对象。

### 直接赋值

其实就是对象的引用（别名）

### 引用计数

#### 概述

要保持追踪内存中的对象，Python使用了引用计数这一技术

`sys.getrefcount(a)`可以查看a对象的引用计数，但是比正常计数大1，因为调用函数的时候传入a，这会让a的引用计数+1

```python
a = [1, 2]
b = a
```

#### 引用计数的增减

##### 2.1 增加引用计数

当对象被创建并（将其引用）赋值给变量时，该对象的引用计数被设置为1。

对象的引用计数增加的情况：

- 对象被创建：`x = 3.14`
- 另外的别名被创建：`y = x`
- 对象被作为参数传递给函数（新的本地引用）：`foobar(x)`
- 对象成为容器对象的一个元素：`my_list = [123, x, 'xyz']`

##### 2.2 减少引用计数

对象的引用计数减少的情况：

- 一个本地引用离开了其作用范围。例如`fooc()`函数结束时，`func`函数中的局部变量都被自动销毁（全局变量不会）
- 对象的别名被del语句显式销毁（同时该变量从命名空间中删除）：`del y`
- 对象的一个别名被赋值给其他对象：`x = 123`
- 对象被从一个容器对象中移除：`my_list.remove(x)`
- 容器对象本身被销毁，自身的引用计数为0：`del my_list`

##### 2.3 del语句

Del语句会删除对象的一个引用，它的语法如下：`del obj[, obj2[, ...objN]]`

例如，在上例中执行`del y`会产生两个结果：

- 从现在的名称空间中删除`y`
- `x`的引用计数减1

### 浅拷贝(copy.copy())：拷贝父对象，不会拷贝对象的内部的子对象

1、对于不可变类型，例如：`Num，Str，Tuple`，浅拷贝仅仅是地址指向改变，不会开辟新空间。
2、对于可变类型，例如：`List、Dict、Set`，浅拷贝会开辟新的空间地址(仅仅是最顶层开辟了新的空间，里层的元素地址还是一样的)，进行浅拷贝
3、浅拷贝后，改变原始对象中为可变类型的元素的值，会同时影响拷贝对象；改变原始对象中为不可变类型的元素的值，只有原始类型受影响。（操作拷贝对象对原始对象的也是同理）

4、`list[:]`、`dict.copy()`类似于浅拷贝操作。

### 深拷贝(copy.deepcopy())：完全拷贝了父对象及其子对象

1、如果每一层都是不可变类型，深拷贝依然拷贝的是引用（可能指引用计数），不会创建新的内存。

2、如果有一层是可变对象，则深拷贝会拷贝每一层，新建内存。

### 关于深浅拷贝的总结：

1、如果变量内部的数据每一层都是不可变类型，深拷贝和浅拷贝都是地址指向

2、如果**变量最外层是可变类型，浅拷贝会拷贝最外层，开辟新的空间**，id改变；**深拷贝会拷贝所有的可变类型，开辟新的空间**，id改变。

3、如果变量数据的最外层是不可变类型，内部包含有可变数据，浅拷贝会对最外层做地址指向，id不变；深拷贝开辟新的空间，id改变，并拷贝内部所有的可变类型。

对于简单的 object，例如不可变对象（数值，字符串，元组），用 shallow copy 和 deep copy 没区别

复杂的 object， 如 list 中套着 list 的情况，**shallow copy 中的 子list，并未从原 object 真的「独立」出来。也就是说，如果你改变原 object 的子 list 中的一个元素，你的 copy 就会跟着一起变。**这跟我们直觉上对「复制」的理解不同。

### 正文

### 如何自己实现一个浅拷贝后者深拷贝方法？

我们可以想到，开发中可定会有需要使用到副本的时候，这时可以自己实现复制的方法，python中有很多对象，每一个开发者都去针对每一种对象实现一个复制函数，极大的增加了工作量，同时每一个开发者写法不一，没有统一。那可不可以封装一个函数，供开发者直接调用即可？

于是一个复制函数呼之欲出，则需求出现了。这个时候需要考虑不同对象类型的复制情况：

```python
针对不可变对象，则定义复制函数为：
def copy_immutable(x):
    return x

针对可变对象,不同对象类型的复制方法不一：
def copy_of_list(x):
    y = []
    for i in x:
        y.append(i)
    return y

def copy_of_set(x):
    y = set()
    for i in x:
        y.add(i)
    return y

def copy_of_dict(x):
    y = {}
    for k,v in x:
        y[k]=v
    return y
```

复制的方法定义好了，我们希望做进一步优化，包装一个函数，可以判断输入对象的类型，然后获取对应的复制方法，这样就可以有统一的接口了，代码如下：

```python
# 定义不可变对象的类型清单，这里用的元组而非列表，这有什么好处了？
# 当前模块定义的全局使用的可变对象元组 相比使用列表或者集合有什么好处了？
# 元组有哪些好处了？
immutable_object_tuple = (type(None), int, float, bool, complex, str, tuple,bytes, frozenset)

# 定义复制解析字典，通过对象类型获取对应的复制方法
copy_dispatch =d={}
for t in immutable_object_tuple:
    d[t]= copy_immutable
d[list]=copy_of_list
d[set]=copy_of_set
d[dict]=copy_of_dict

# 定义统一的复制函数，通过类型自动获取对应的复制方法
def copy_func_version_one(x):
    cls = type(x)  # 获取对象类型
    copy_method = copy_dispatch[cls] # 假设解析方法已经包含了所有的类型，实际是没有了，后续再优化
    return copy_method(x)
```

这个时候初步的复制函数出来了，可以类比为内建copy方法的雏形，在使用时可以满足基本的复制需求，但是如果可变对象嵌套可变对象了？用列表举例如下：

```python
nest_one = [4, 5]
test_list_one = [1, 2, 3, nest_one]
copy_of_test_list_one = copy_of_list(test_list_one)

print(id(test_list_one))
print(id(copy_of_test_list_one))
# 139840569478192
# 139840540438032
# 可见复制后生成了 新的对象

print(id(copy_of_test_list_one[-1]))
print(id(test_list_one[-1]))
#139840569475632
#139840569475632
# 复制后的嵌套可变对象是同一个内存地址，是同一个对象，共用的test_one
```

### 总结：

可以发现内嵌的可变对象复制的时候没有生成新的对象，而还是以前的对象，当其中一个嵌套可变对象发生改变时，另外一个也会发生变化，复制时候感觉只复制了一层，我们叫这个为浅拷贝Shallow copy，那如何实现一个深拷贝了(deepcopy)?

### 补充知识： 列表复制的多种方法

总结：**可见几种复制方法中除了deepcopy，其他都是浅拷贝，尤其注意list()方法的复制为浅拷贝**

```python
# python 内建模块copy
import copy

L1 = [1, 2, [3]]
L2 = L1					# 直接赋值
L3 = L1[:]				# 完全切片操作，浅拷贝
L4 = list(L1)			# 工厂函数，浅拷贝
L5 = copy.copy(L1)		# 浅拷贝
L6 = copy.deepcopy(L1)	# 深拷贝

if __name__ == '__main__':
    print('L1 id is :{}'.format(id(L1)))
    print('L1[2] id is :{}'.format(id(L1[2])))

    print('L3 id is :{}'.format(id(L3)))
    print('L3[2] id is :{}'.format(id(L3[2])))

    print('L4 id is :{}'.format(id(L4)))
    print('L4[2] id is :{}'.format(id(L4[2])))

    print('L5 id is :{}'.format(id(L5)))
    print('L5[2] id is :{}'.format(id(L5[2])))

    print('L6 id is :{}'.format(id(L6)))
    print('L6[2] id is :{}'.format(id(L6[2])))

# 输出
L1 id is :2148361819400
L1[2] id is :2148361819208
L3 id is :2148361820680
L3[2] id is :2148361819208
L4 id is :2148360362312
L4[2] id is :2148361819208
L5 id is :2148361820616
L5[2] id is :2148361819208
L6 id is :2148361820552
L6[2] id is :2148361820488
```

文章参考[python-深度知识篇-copy(浅拷贝)deepcopy(深拷贝)](<https://zhuanlan.zhihu.com/p/118663392>)