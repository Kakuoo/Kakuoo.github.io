---
layout: post
title: Python面向对象
subtitle: false
tags: [Python]
---


<!-- # Python面向对象 -->

类名——满足大驼峰命名法（CapWords）

- 对**对象的特征描述**，通常可以定义为 **属性**
- **对象具有的行为**（动词），通常可以定义为**方法**

## 面向对象基础语法

### 1.dir内置函数

在python中，对象无处不在，**变量**、**数据**和**函数**都是对象，在python中可以使用以下两个方法验证：

1. 在**标识符/数据** 后输入一个`.`，然后按下`TAB`键，`ipython`会提示该对象能够调用的**方法列表**
2. 在使用内置函数`dir`传入**标识符/数据**，可以查看对象内的**所有属性及方法**

**提示**`__方法名__` 格式的方法是python提供的**内置方法/属性**

|    方法名    | 类型 | 作用                                       |
| :----------: | ---- | ------------------------------------------ |
| \_\_new\_\_  | 方法 | **创建对象**时，会被**自动**调用           |
| \_\_init\_\_ | 方法 | **对象被初始化**时，会被**自动**调用       |
| \_\_del\_\_  | 方法 | **对象被从内存中销毁**前，会被**自动**调用 |
| \_\_str\_\_  | 方法 | 返回**对象的描述信息**，print函数输出使用  |

> 提示：利用好dir()函数，在学习时很多内容就不需要死记硬背了

### 2.定义简单的类（只包含方法）

> 面向对象时更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了

#### 2.1定义只包含方法的类

```python
class 类名:
	def 方法1(self, 参数列表):
		pass
	def 方法2(self, 参数列表):
		pass
```

> 类名的命名规则要符合大驼峰命名法

#### 2.2创建对象

当一个类定义完成之后，要使用这个类来创建对象

```python
对象变量 = 类名()
```

#### 引用概念的强调

> 在面向对象开发中，**引用**的概念是同样适用的

在python中使用类**创建对象之后**，实例化的变量中仍然记录的是**对象在内存中的地址**，也就是实例化的变量**引用**了**新建的对象**，使用print输出**对象变量**，默认情况下，是能够输出这个变量 **引用的对象** 是 **由哪一个类创建的对象**，以及 在内存中的地址(十六位进制表示)

> 提示：在计算机中，通常使用 **十六进制** 表示 **内存地址**
>
> - 十进制 和 十六进制 都是用来表达数字的，只是表示的方式不一样
> - 十进制 和 十六进制 的数字之间可以来回转换

- %d 以 十进制 输出数字
- %x 以 十六进制 输出数字

### 3.方法中的self参数

在Python中，要给对象设置属性，非常容易，只需要在类的外部的代码中直接通过`.`设置一个属性即可，但是不推荐使用，因为：对象属性的封装应该封装在类的内容

由**哪一个对象**调用的方法，`self`就是**哪一个对象的引用**

- 在类封装的方法内部，`self`就表示**当前调用方法的对象自己**
- **调用方法时**，程序员不需要传递`self`参数
- 在方法内部
  - 可以通过`self.`**访问对象的属性**
  - 也可以通过`self.`**调用这个对象的其他方法**

### 4.初始化方法

 在日常开发中，不推荐在类的外部给对象增加 属性，如果在运行时，没有找到属性，程序会报错（对象应该包含有哪些属性，应该封装在类的内部）

当使用类名()创建对象时，会**自动**执行以下操作：

1. 为对象在内存中 **分配空间**——创建对象
2. 为对象的属性 **设置初始值**——初始化方法（init）

这个**初始化方法**就是`__init__`方法，`__init__`是对象的**内置方法**

> `__init__`方法是**专门**用来定义一个类 **具有哪些属性的方法**

```python
# 在Cat类中增加__init__方法，验证该方法在创建对象时会被自动调用
class Cat:
""""""
	def __init__(self):
		print("这是一个初始化方法")
        
>>> tom = Cat()
这是一个初始化方法
```

**在初始化方法内部定义属性**

- 在`__init__`方法内部使用`self.属性名 = 属性的初始值`就可以定义属性
- 定义属性之后，再使用类创建的对象，都会拥有该属性

**改造初始化方法——初始化的同时设置初始值**

在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对`__init__`方法进行改造

1. 把希望设置的属性值，定义成`__init__`方法的参数
2. 在方法内部使用`self.属性 = 形参`接收外部传递的参数
3. 在创建对象时，使用`类名(属性1, 属性2...)`调用

```
class Cat:
""""""
	def __init__(self, new_name):
		print("这是一个初始化方法")
		
		self.name = new_name
	def eat(self):
		print("%s 爱吃鱼" % self.name)
	
tom = Cat("Tom")
lazy_cat = Cat("Lazy cat")

```

### 5.内置方法和属性

| 方法名    | 类型 | 作用                                       |
| --------- | ---- | ------------------------------------------ |
| \_\_del__ | 方法 | **对象被从内存中销毁**前，会被**自动**调用 |
| \_\_str__ | 方法 | 返回**对象的描述信息**，print函数输出使用  |

#### \_\_del__方法

- 当使用`类名()`创建对象时，为对象**分配完空间**后，**自动**调用`__init__`方法
- 当一个**对象被从内存中销毁**时，会**自动**调用`__del__`方法

应用场景

- `__init__`改造初始化方法，可以让创建对象更加灵活
- `__del__`如果希望在对象销毁前，再做一些事情，可以考虑一下`__del__`方法

生命周期

- 一个对象从调用类名()创建，生命周期开始
- 一个对象的`__del__`方法一旦被调用，生命周期结束
- 在对象的生命周期内，可以访问对象属性，或者让对象调用方法

#### \_\_str__方法

- 在python中，使用`print`输出对象变量，默认情况下，会输出这个变量**引用的对象**是**由哪一个类创建的对象**，以及**在内存中的地址**（十六进制表示）
- 如果在开发中，希望使用`print`输出**对象变量**时，能够打印**自定义的内容**，就可以利用`__str__`这个内置方法

> 注意：`__str__`方法必须返回一个字符串，return string



## 面向对象——封装

> 一个对象的**属性**可以是**另外一个类创建的对象**

### 定义没有初始值的属性

在定义属性时，如果 **不知道设置什么初始值**，可以设置为`None`

- `None`**关键字**表示**什么都没有**
- 表示一个**空对象**，**没有方法和属性**，**是一个特殊的常量**
- 可以将None赋值给任何一个变量

### 身份运算符

身份运算符用于比较两个对象的**内存地址**是否一致——**是否是对同一个对象的引用**

在python中，针对`None`比较时，建议使用`is`判断

| 运算符 | 描述                                      | 实例                              |
| :----: | ----------------------------------------- | --------------------------------- |
|   is   | is 是判断两个标识符是不是引用同一个对象   | x is y， 类似  id(x) == id(y)     |
| is not | is not 是判断两个标识符是不是引用不同对象 | x is not y， 类似  id(x) != id(y) |

`is` 与 `==` 区别

- `is` 用于判断**两个变量引用对象是否为同一个**
- `==` 用于判断**引用变量的值** 是否相等

```python
>>> a = [1, 2, 3]
>>> b = [1, 2, 3]
>>> b is a 
False
>>> b == a
True
```

###  私有属性和私有方法

应用场景和定义方式

- 在实际开发中，**对象**的 **某些属性和方法** 可能只希望**在对象的内部被使用**，**不希望在外部被访问到**
- 私有属性就是对象不希望公开的属性
- 私有方法就是对象不希望公开的方法

在**定义属性或方法时**，在**属性名或者方法名前**增加**两个下划线**，定义的就是**私有**属性或方法

```python
# 私有属性

class Women:
    def __init__(self, name):
        self.name = name
        self.__age = 18

    # 在对象的方法内部，可以访问对象的私有属性
    def secret(self):
        print("%s 的年龄是：%d" % (self.name, self.__age))

xiaofang = Women("xiaofang")

# 私有属性，在外部不能访问
# print(xiaofang.__age)

xiaofang.secret()
```

```python
# 私有方法

class Women:
    def __init__(self, name):
        self.name = name
        self.__age = 18

    # 在对象的方法内部，可以访问对象的私有属性
    def __secret(self):
        print("%s 的年龄是：%d" % (self.name, self.__age))

xiaofang = Women("xiaofang")

# 私有属性，在外部不能访问
# print(xiaofang.__age)

# 私有方法，在外部不能访问
xiaofang.__secret()
```

### 伪私有属性和私有方法

> 提示：在日常开发中，**不要使用这种方式，访问对象的私有属性或私有方法**

python中，没有**真正意义**上的**私有**

- 在给**属性**、**方法**命名时，实际是对**名称**做了一些特殊处理，使得外界无法访问到
- **处理方式**：在**名称**前加上`_类名` => `_类名__名称`

```python
# 私有属性，在外部不能直接访问
print(xiaofang._Women__age)

# 私有方法，在外部不能直接访问
xiaofang._Women__secret()
```



## 面向对象——继承

继承的概念：子类拥有父类的所有属性和方法

继承的传递性：同样的，子类拥有父类以及父类的父类中封装的所有 属性和方法

专业术语：

- `Dog`类是`Animal`类的**子类**，`Animal`类是`Dog`类的**父类**，`Dog`类从`Animal`类**继承**
- `Dog`类是`Animal`类的**派生类**，`Animal`类是`Dog`类的**基类**，`Dog`类从`Animal`类**派生**

### 方法重写

**应用场景**：当父类的方法实现不能满足子类需求时，可以对方法进行**重写（override）**

重写 父类方法的两种情况：

1. **覆盖**父类的方法
2. 对父类方法进行**扩展**

1）覆盖父类的方法

- 如果在开发中，父类的方法实现 和 子类的方法实现，完全不同
- 就可以使用覆盖的方式，在子类中重新编写父类的方法实现

> 具体的实现方式，就相当于在 **子类** 中定义了一个和 **父类同名的方法并且实现**

重写之后，在运行时，**只会调用**子类中重写的方法，而不会再调用**父类封装的方法**

2）对父类方法进行扩展

- 如果在开发中，**子类的方法实现** 中 **包含父类的方法实现**
  - **父类原本封装的方法实现** 是 **子类方法的一部分**
- 就可以使用扩展的方式
  1. 在子类中 **重写**父类的方法
  2. 在需要的位置使用`super().父类方法` 来调用父类方法的执行
  3. 代码其他的位置针对子类的需求，编写 **子类特有的代码实现**

**关于super**

- 在python中`super`是一个**特殊的类**
- `super()`就是使用`super`类创建出来的对象
- **最常**使用的场景就是重写父类方法时，调用**在父类中封装的方法实现**

```python
class Dog():
    def bark(self):
        print("汪汪叫")


class XiaoTianQuan(Dog):
    def fly(self):
        print("我会飞")

    def bark(self):
        # 1.针对子类特有的需求，编写代码
        print("神一样的叫唤...")

        # 2.使用super()，调用原本在父类中封装的代码
        super().bark()

        # 3.增加其他子类的代码
        print("$%$%$%%$%$")

xtq = XiaoTianQuan()
xtq.bark()

# 输出结果
神一样的叫唤...
汪汪叫
$%$%$%%$%$
```

**调用父类方法的另一种方式**

> 在`python2.x`时，如果需要调用父类的方法，还可以使用以下方式

```python
父类名.方法(self)
```

- 这种方式，目前在`python3.x`还支持这种方式
- 这种方式 **不推荐使用**，因为一旦父类发生变化，方法调用位置的**类名**同样需要修改

> 提示：
>
> - 在开发时，`父类名`和`super()`两种方式不要混用
> - 如果使用**当前子类名**调用方法，会形成递归调用，**出现死循环**

```python
class Dog():
    def bark(self):
        print("汪汪叫")


class XiaoTianQuan(Dog):
    def fly(self):
        print("我会飞")

    def bark(self):
        # 1.针对子类特有的需求，编写代码
        print("神一样的叫唤...")

        # 2.使用super()，调用原本在父类中封装的代码
        # super().bark()
        
        # 以父类名.方法(self)
        Dog.bark(self)
        
        # 若此时写错类名，本应使用父类名，此处却使用当前子类名调用方法，会出现递归死循环
        XiaoTianQuan.bark(self)

        # 3.增加其他子类的代码
        print("$%$%$%%$%$")

xtq = XiaoTianQuan()
xtq.bark()

# 输出结果
神一样的叫唤...
汪汪叫
$%$%$%%$%$
```

### 父类的私有属性和私有方法

1. 子类对象**不能**在自己的方法内部，**直接**访问**父类**的私有属性和私有方法
2. 子类对象可以通过**父类**的**公有方法** **间接**访问到私有属性或私有方法

> - **私有属性、方法**是对象的隐私，不对外公开，**外界**以及**子类**都不能直接访问
> - **私有属性、方法**通常用于做一些内部的事情

```python
class A():
    def __init__(self):
        self.num1 = 100
        self.__num2 = 200

    def __test(self):
        print("私有方法 %d %d" % (self.num1, self.__num2))

    def test(self):
        print("父类的公有方法 %d" % self.__num2)
        self.__test()


class B(A):

    def demo(self):
        # # 1. 在子类的对象方法中，不能访问父类的私有属性
        # print("访问父类的私有属性 %d %d" % self.__num2)
        #
        # # 2. 在子类的对象方法中，不能调用父类的私有方法
        # self.__test()

        # 3. 可以访问父类的公有属性
        print("子类方法 %d" % self.num1)

        # 4. 可以调用父类的公有方法
        self.test()

        
b = B()
print(b)
b.demo()
```

### 多继承

概念：

- 子类可以拥有**多个父类**，并且具有**所有父类**的属性和方法
- 例如：孩子会继承自己父亲和母亲的特性

```python
class 子类名(父类名1, 父类名2...):
	pass
```

**多继承的使用注意事项**

> 如果**不同的父类**中存在**同名的方法**，**子类对象**在调用方法时，会调用**哪一个父类**中的方法呢？
>
> 提示：开发时，应该尽量避免这种容易产生混淆的情况！——如果**父类之间**存在**同名的属性或方法**，应该**尽量避免使用多继承**

**python中的MRO——方法搜索顺序**

- python中针对**类**提供了一个**内置属性**`__mro__`可以查看方法搜索顺序
- `MRO`是`method resolution order`，主要用于在多继承时判断方法、属性的调用路径

```python
print(className.__mro__)
```

- 在搜索方法时，是按照`__mro__`的输出结果从左至右的顺序查找的
- 如果在当前类中**找到方法，就直接执行，不再搜索**
- 如果**没有找到**，**就查找下一个类**中是否有相应的方法，**如果找到，就直接执行，不再搜索**
- 如果找到最后一个类，还没有找到方法，程序就报错

**新式类和旧式（经典）类**

> `object`是python为所有对象提供的**基类**，提供有一些内置的属性和方法，可以使用`dir`函数查看

新式类：以`object`为基类的类，推荐使用

经典类：不以`object`为基类的类，不推荐使用

- 在`python3.x`中定义类时，如果没有指定父类，会**默认**使用`object`作为该类的基类——`python3.x`中定义的类都是`新式类`
- 在python2.x中定义类时，如果没有指定父类，则不会以object作为基类

> **新式类**和**经典类**在多继承时——**会影响到方法的搜索顺序**

为了保证编写的代码能够同时在`python2.x`和`python3.x`运行，今后在定义类时，**如果没有父类，建议统一继承自**`object`

```python
class 类名(object):
	pass
```

## 面向对象——多态

不同的**子类对象**调用相同的**父类方法**，产生不同的执行结果

- 多态 可以 增加代码的灵活度
- 以 **继承** 和 **重写父类方法 **为前提
- 是调用方法的技巧，不会影响到类的内部设计

```python
class Dog(object):

    def __init__(self,  name):
        self.name = name

    def game(self):
        print("%s 蹦蹦跳跳的玩耍" % self.name)


class XiaoTianQuan(Dog):

    def game(self):
        print("%s 飞到天上去玩耍" % self.name)


class Person(object):

    def __init__(self, name):
        self.name = name

    def game_with_dog(self, dog):
        print("%s 和 %s 快乐的玩耍" % (self.name, dog.name))

        # 让狗玩耍
        dog.game()

# 1. 创建一个狗对象
# 多态 不同的子类对象调用相同的方法，产生不同的结果
wangcai = Dog("旺财")
wangcai = XiaoTianQuan("飞天旺财")

# 2. 创建一个小明对象
xiaoming = Person("小明")

# 3. 让小明调用和狗玩的方法
xiaoming.game_with_dog(wangcai)
```

## 类属性

### 类的结构

- 创建出来的对象叫做 类 的实例，创建对象的动作叫做 实例
- 对象的属性叫做 实例属性，对象调用的方法叫做 实例方法

注意：

- **每一个对象**都有自己**独立的内存空间**，**保存各自不同的属性**
- **多个对象的方法**，**在内存中只有一份**，在调用方法时，需要把**对象的引用**传递给方法内部的`self`

### 类是特殊的对象

> Python中 **一切皆对象**：
>
> `class AAA:` 定义的类属于**类对象**
>
> `obj1 = AAA()`，属于**实例对象**

- 在程序运行时，类同样**会被加载到内存**
- 在python中，类是一个特殊的对象——**类对象**
- 在程序运行时，**类对象**在内存中**只有一份**，使用**一个类**可以创建出**很多个对象实例**
- 除了封装**实例**的**属性和方法**外，**类对象**还可以拥有**自己的属性和方法**
  1. 类属性
  2. 类方法
- 通过`类名.` 的方式可以**访问类的属性**或者**调用类的方法**

### 类属性和实例属性

**概念和使用**

- 类属性就是给类对象定义的属性
- 通常用来记录与这个类相关的特征
- 类属性**不会用于**记录**具体对象的特征**

> 示例需求
>
> - 定义一个工具类
> - 每件工具都有自己的`name`
> - 需求——知道使用这个类，创建了多少个工具对象

```python
class Tool(object):

    count = 0

    def __init__(self, name):
        self.name = name

        # 让类属性的值+1
        Tool.count += 1

# 1. 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("水桶")

# 2. 输出工具对象的总数
print(Tool.count)
```

**属性的获取机制**

在python中属性的获取存在一个 **向上查找机制**，因此，访问类属性有两种方式

1. 类名.类属性
2. 对象.类属性（不推荐）
   - 首先在对象内部**查找对象属性**
   - 没有找到就会**向上寻找类属性**

```python
# 相同结果
print(Tool.count)

print(tool1.count)
print(tool2.count)
print(tool3.count)
```

**注意**：

- 如果使用`对象.类属性 = 值`赋值语句，只会**给对象添加一个属性**，而不会影响到**类属性的值**

```python
class Tool(object):

    count = 0

    def __init__(self, name):
        self.name = name

        # 让类属性的值+1
        Tool.count += 1

# 1. 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")
tool3 = Tool("水桶")

# 2. 输出工具对象的总数
tool3.count = 99
print("工具对象总数 %d" % tool3.count)	# 输出 99
print("====> %d" % Tool.count)	# 输出 3
```

### 类方法和静态方法

**类方法**

类属性就是针对类对象定义的属性

- 使用赋值语句在class关键字下方可以定义类属性
- 类属性用于记录与这个类相关的特征

类方法就是针对类对象定义的方法

- 在**类方法**内部可以直接访问**类属性**或者调用其他的**类方法**

语法如下：

```python
@classmethod
def 类方法名(cls):
	pass
```

- 类方法需要使用**修饰器**`@classmethod`来标识，**告诉解释器这是一个类方法**
- 类方法的**第一个参数**应该是`cls`
  - 由**哪一个类**调用的方法，方法内的`cls`就是**哪一个类的引用**
  - 这个参数和**实例方法**的第一个参数是`self`类似
  - **提示** 使用其他名称也可以，不过习惯使用`cls`
- 通过`类名.`调用类方法，**调用方法时**，不需要传递`cls`参数
- **在方法内部**
  - 可以通过`cls.`**访问类属性**
  - 也可以通过`cls.`**调用其他的类方法**

```python
class Tool(object):

    count = 0
    
	@classmethod
	def show_tool_count(cls):
		print("工具对象的数量 %d" % cls.count)
		
    def __init__(self, name):
        self.name = name

        # 让类属性的值+1
        Tool.count += 1

# 1. 创建工具对象
tool1 = Tool("斧头")
tool2 = Tool("榔头")

# 调用类方法
Tool.show_tool_count()
```

**静态方法**

在开发时，如果需要在类中封装一个方法，这个方法有以下特性，则可以把这个方法封装成一个静态方法

- 既不需要访问实例属性或者调用实例方法
- 也不需要访问类属性或者调用类方法

语法如下：

```python
@staticmethod
def 静态方法名()
	pass
```

**静态方法**需要使用**修饰器**`@staticmethod`来标识，**告诉解释器这是一个静态方法**，并通过`类名.`调用静态方法

```python
class Dog(object):
    
	@staticmethod
	def run():
		
		# 不访问实例属性/类属性
		print("啦啦啦")
		
# 通过 类名. 调用静态方法，不需要创建对象		
Dog.run()
```



## 方法综合案例

需求

1. 设计一个Game类
2. 属性：
   - 定义一个类属性`top_score`记录游戏的历史最高分
   - 定义一个实例属性`player_name`记录当前游戏玩家姓名
3. 方法：
   - **静态方法**`show_help`显示游戏帮助信息
   - **类方法**`show_top_score`显示历史最高分
   - **实例方法**`start_game`开始当前玩家的游戏
4. 主程序步骤
   1. 查看帮助信息
   2. 查看历史最高分
   3. 创建游戏对象，开始游戏

```python
class Game(object):

    # 历史最高分
    top_score = 0

    def __init__(self, player_name):
        self.player_name = player_name

    @staticmethod
    def show_help():
        print("帮助信息...")

    @classmethod
    def show_top_score(cls):
        print("历史记录 %d" % cls.top_score)

    def start_game(self):
        print("%s 开始游戏啦" % self.player_name)


# 1. 查看游戏的帮助信息
Game.show_help()

# 2. 查看历史最高分
Game.show_top_score()

# 3. 创建游戏对象
game = Game("小明")
game.start_game()
```

**案例小结**

1. **实例方法**——方法内部需要访问**实例属性**
   - 实例方法内部可以使用`类名.`访问类属性
2. **类方法**——方法内部 **只** 需要访问**类属性**
3. **静态方法**——方法内部，不需要访问**实例属性**和**类属性**



## 单例

### 单例设计模式

设计模式：前人工作的总结提炼，通常，被人们广泛流传的设计模式都是针对某一特定问题的成熟的解决方案，使用设计模式是为了可重用代码，让代码更容易理解，保证代码的可靠性

**单例设计模式**

- 目的——让**类**创建的对象，在系统中**只有唯一的一个实例**
- 每一次执行`类名()`返回的对象，**内存地址是相同的**

### \_\_new__方法

- 使用`类名()`创建对象时，`python`的解释器**首先**会调用`__new__`方法为对象**分配空间**
- `__new__`是一个由`object`基类提供的**内置的静态方法**，主要作用有两个：
  1. 在内存中为对象 **分配空间**
  2. 返回 **对象的引用**
- `python`的解释器获得对象的**引用**后，将引用作为**第一个参数**，传递给`__init__`方法

> 重写`__new__`方法的代码非常固定！

- 重写`__new__`方法**一定要返回分配的内存空间**`return super().__new__(cls)`
- 否则`python`的解释器**得不到**分配了空间的**对象引用**，**就不会调用对象的初始化方法**
- 注意：`__new__`是一个静态方法，在调用时需要**主动传递**`cls`参数


```python
class MusicPlayer(object):

    def __new__(cls, *args, **kwargs):

        # 1. 创建对象时，new方法会自动被调用
        print("创建对象，分配空间")

        # 2. 为对象分配空间
        instance = super().__new__(cls)

        # 3. 返回对象的引用
        return instance

    def __init__(self):
       print("播放器初始化")


player = MusicPlayer()
```

### Python中的单例

单例——让类创建的对象在系统中**只有唯一的一个实例**

1. 定义一个**类属性**，初始值是`None`，用于记录**单例对象的引用**
2. 重写`__new__`方法
3. 如果类属性`is None`，调用父类方法分配空间，并在类属性中记录结果
4. 返回类属性中记录的**对象引用**

```python
class MusicPlayer(object):

    # 记录第一个被创建的对象的引用
    instance = None

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否是空对象
        if cls.instance is None:
            # 2.调用父类的方法为第一个对象分配空间
            cls.instance = super().__new__(cls)
            # 3.返回类属性保存的对象引用
        return cls.instance

    
player1 = MusicPlayer()
player2 = MusicPlayer()
```

只执行一次初始化工作

- 在每次使用`类名()`创建对象时，python解释器都会自动调用两个方法：
  - `__new__`分配空间
  - `__init__`对象初始化

- 在上一次改造中，每次都会得到**第一次被创建对象的引用**
- 但是：**初始化方法还会被再次调用**

**问题：**如果希望，让初始化动作只被执行一次

**解决办法**

1. 定义一个类属性`init_flag`标记是否执行过初始化动作，初始值为`False`
2. 在`__init__`方法中，判断`init_flag`，如果为`False`就执行初始化动作
3. 然后将`init_flag`设置为`True`
4. 如此这般，再次自动调用`__init__`方法时，**初始化动作就不会被再次执行**

```python
class MusicPlayer(object):

    # 记录第一个被创建的对象的引用
    instance = None
    # 记录是否执行过初始化动作
    init_flag = False

    def __new__(cls, *args, **kwargs):

        # 1. 判断类属性是否是空对象
        if cls.instance is None:
            # 2.调用父类的方法为第一个对象分配空间
            cls.instance = super().__new__(cls)
            # 3.返回类属性保存的对象引用
        return cls.instance

    def __init__(self):

        # 1. 判断是否执行过初始化动作
        if MusicPlayer.init_flag:
            return

        # 2. 如果没有执行过，则执行初始化动作
        print("播放器初始化")

        # 3. 修改类属性的标记
        MusicPlayer.init_flag = True


player1 = MusicPlayer()
player2 = MusicPlayer()
```

